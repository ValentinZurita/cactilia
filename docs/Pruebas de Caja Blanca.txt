IntroducciónEste documento presenta el Plan de Pruebas de Caja Blanca, aplicando la técnica del camino básico, para validar la lógica interna de los componentes principales del sistema Sistema Web de E - Commerce SEC desarrollado por HolodevObjetivo? Asegurar que todas las rutas lógicas del código se ejercitan al menos una vez.? Verificar todas las decisiones en sus ramas verdadera y falsa.? Probar bucles en sus límites y condiciones operacionales.? Validar estructuras de datos internas, asegurando su integridad.Alcance? Este plan abarca la funcionalidad principal (Core) del sistema:? Módulo Público: Home, páginas informativas, navegación principal? Módulo de Shop: Catálogo, detalles de productos, carrito? Módulo de Checkout: Proceso de pago, sistema de envíos, integración con Stripe? Módulo de Usuario: Gestión de cuentas, perfiles, historial? Módulo de Administración: Panel de control, gestión de productos, pedidos? Módulo de Autenticación: Registro, login, recuperación de contraseñasDatos GeneralesInformaciónDetalleNombre del estudianteValentin Alejandro Perez ZuritaMatrículaES1921014024OrganizaciónHOLODEV, S.A. DE C.VTítulo del proyectoSistema Web de E - Commerce SEC desarrollado por HolodevURL del sistemahttps://cactilia-3678a.web.app/Credenciales de accesoUsuario: valentin.alejandro@outlook.comContraseña: Alejandro123Versión del documento1.0Fecha de elaboración14 de Abril del 2025Resumen de Pruebas de Caja BlancaTabla Pruebas ManualesNo°Nombre de la PruebaDescripciónFechaResponsableHistoria RelacionadaPCB-M-01Validación de campos en registroVerifica caminos lógicos en la validación de datos del formulario de registro13/04/2025Valentin Alejandro Perez ZuritaHU-A01: Registro de usuarioPCB-M-02Autenticación de usuarioVerifica caminos en el proceso de autenticación con credenciales14/04/2025Valentin Alejandro Perez ZuritaHU-A02: Login de usuarioPCB-M-03Cálculo de costo de envíoPrueba caminos en el algoritmo que calcula costos de envío14/04/2025Valentin Alejandro Perez ZuritaHU-C03: Cálculo de envíoPCB-M-04Proceso de autorización por rolesEvalúa control de acceso a áreas administrativas según rol del usuario14/04/2025Valentin Alejandro Perez ZuritaHU-A05: Gestión de sesionesPCB-M-05Gestión de cantidades en carritoLógica de incremento/decremento en el carrito y actualización de totales15/04/2025Valentin Alejandro Perez ZuritaHU-S06: Gestión de cantidadesPCB-M-06Filtrado de productos por precioVerifica el filtrado por rangos de precio y otras características15/04/2025Valentin Alejandro Perez ZuritaHU-S03: Filtros de precioPCB-M-07Gestión de inventario administrativoLógica de actualización de stock y alertas de inventario bajo15/04/2025Valentin Alejandro Perez ZuritaHU-AD03: Gestión de inventarioPCB-M-08Procesamiento de confirmación de pagoPrueba lógica del sistema al detectar y procesar pagos15/04/2025Valentin Alejandro Perez ZuritaHU-C08: Confirmación de pagoPCB-M-09Búsqueda avanzada de productosAlgoritmo de búsqueda por palabras clave y filtros combinados16/04/2025Valentin Alejandro Perez ZuritaHU-P03: Búsqueda de productosPCB-M-10Actualización de estados de pedidoFlujo de estados del pedido y notificaciones correspondientes16/04/2025Valentin Alejandro Perez ZuritaHU-AD05: Estado de pedidosTabla Pruebas AutomatizadasN°Nombre de la PruebaDescripciónFechaResponsableHerramientaHistoria RelacionadaPCB-A-01Validación de emailValidación de formatos de email en el registro13/04/2025[Tu nombre]JestHU-A01: Registro de usuarioPCB-A-02Validación de contraseñaVerificación de requisitos de seguridad para contraseñas13/04/2025[Tu nombre]JestHU-A01: Registro de usuarioPCB-A-03Verificación de emailProceso de envío y validación de verificación de email13/04/2025[Tu nombre]JestHU-A04: Verificación de emailPCB-A-04Cálculo de subtotalesCálculo de precios y cantidades en el carrito13/04/2025[Tu nombre]JestHU-S07: Resumen de carritoPCB-A-05Integración con StripeLógica de comunicación con pasarela de pago13/04/2025[Tu nombre]JestHU-C05: Integración StripePCB-A-06Validación de direccionesValidación de campos en formulario de direcciones13/04/2025[Tu nombre]JestHU-U01: Múltiples direccionesPCB-A-07Gestión de categoríasCreación y modificación de categorías13/04/2025[Tu nombre]JestHU-AD02: Gestión de categoríasPCB-A-08Gestión de historial de pedidosRecuperación y visualización de pedidos del usuario13/04/2025[Tu nombre]JestHU-U03: Historial de pedidosPCB-A-09Detalle de productoCarga y presentación de información del producto13/04/2025[Tu nombre]JestHU-S02: Detalles de productoPCB-A-10Generación de confirmación de pedidoLógica que genera el resumen final antes de pagar13/04/2025[Tu nombre]JestHU-C01: Revisión de compraPruebas ManualesPCB-M-01: REGISTRO DE USUARIONoPCB-M-01Nombre de la PruebaRegistro de usuarioMóduloAutenticaciónDescripciónVerifica caminos lógicos en la validación de datos del formulario de registroHistoria RelacionadaHU-A01: Registro de usuarioFecha13/04/2025ResponsableValentin Alejandro Perez ZuritaCódigo Fuente/** * Registra un nuevo usuario en el sistema * @param {Object} userData - Datos del usuario a registrar * @returns {Promise<Object>} - Resultado de la operación */export const registerUser = async (userData) => {  try {    // Validar que existan los campos requeridos    if (!userData.email || !userData.password || !userData.displayName) {      return {         ok: false,         errorMessage: 'Todos los campos son obligatorios'       };    }      // Validar formato de email    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;    if (!emailRegex.test(userData.email)) {      return {         ok: false,         errorMessage: 'El formato del email es inválido'       };    }      // Validar complejidad de contraseña    if (userData.password.length < 8) {      return {         ok: false,         errorMessage: 'La contraseña debe tener al menos 8 caracteres'       };    }      // Crear usuario en Firebase Authentication    const userCredential = await createUserWithEmailAndPassword(      FirebaseAuth,      userData.email,      userData.password    );      // Obtener el usuario creado    const user = userCredential.user;      // Actualizar el perfil con el nombre de usuario    await updateProfile(user, {      displayName: userData.displayName,      photoURL: userData.photoURL || null    });      // Enviar email de verificación    await sendEmailVerification(user);      // Crear documento de usuario en Firestore    const userRef = doc(FirebaseDB, 'users', user.uid);    await setDoc(userRef, {      uid: user.uid,      email: userData.email,      displayName: userData.displayName,      photoURL: userData.photoURL || null,      role: 'customer',      createdAt: serverTimestamp(),      updatedAt: serverTimestamp()    });      // Cerrar sesión para forzar verificación de email    await FirebaseAuth.signOut();      return {       ok: true,       message: 'Usuario registrado correctamente. Por favor, verifica tu correo electrónico.'    };  } catch (error) {    console.error('Error al registrar usuario:', error.message);      // Manejar errores específicos de Firebase Auth    if (error.code === 'auth/email-already-in-use') {      return {         ok: false,         errorMessage: 'El correo electrónico ya está registrado'       };    }      return {       ok: false,       errorMessage: 'Error al registrar usuario. Inténtalo de nuevo más tarde.'    };  }};Diagrama de flujoCálculo de la Complejidad Ciclomática? Número de regiones: 6? Fórmula Aristas - Nodos + 2:? Nodos: 15? Aristas: 19? Cálculo: V(G) = 19 - 15 + 2 = 6? Nodos predicado + 1:? Nodos predicado (decisiones): 51. ¿Campos requeridos completos? (Nodo 1)2. ¿Formato de email válido? (Nodo 3)3. ¿Contraseña cumple requisitos? (Nodo 5)4. ¿Error de email ya registrado? (Nodo 13)5. Decisión implícita del bloque try-catch (entre nodo 7 y nodo 13)? Cálculo: V(G) = 5 + 1 = 6Conclusión: La complejidad ciclomática es 6, lo que implica que se deben identificar 6 caminos independientes dentro del grafo.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Falta de datos requeridos1(No) ? 2 ? Fin2Email con formato inválido1(Sí) ? 3(No) ? 4 ? Fin3Contraseña demasiado corta1(Sí) ? 3(Sí) ? 5(No) ? 6 ? Fin4Registro exitoso1(Sí) ? 3(Sí) ? 5(Sí) ? 7 ? 8 ? 9 ? 10 ? 11 ? 12 ? Fin5Error: email ya registrado1(Sí) ? 3(Sí) ? 5(Sí) ? 7 ? (excepción) ? 13(Sí) ? 14 ? Fin6Error genérico1(Sí) ? 3(Sí) ? 5(Sí) ? 7 ? (excepción) ? 13(No) ? 15 ? FinDerivación de Casos de Prueba                                                                                                            CaminoCaso de PruebaDatos de EntradaResultado Esperado1Datos incompletosuserData = { email: "usuario@example.com", password: "", displayName: "Usuario" }Retorna { ok: false, errorMessage: 'Todos los campos son obligatorios' }2Email inválidouserData = { email: "usuario@invalido", password: "Password123", displayName: "Usuario" }Retorna { ok: false, errorMessage: 'El formato del email es inválido' }3Contraseña débiluserData = { email: "usuario@example.com", password: "123", displayName: "Usuario" }Retorna { ok: false, errorMessage: 'La contraseña debe tener al menos 8 caracteres' }4Registro exitosouserData = { email: "nuevo@example.com", password: "Password123", displayName: "Usuario Nuevo" }Se crea el usuario en Firebase Auth, se actualiza su perfil, se envía email de verificación, se crea documento en Firestore, se cierra sesión y retorna { ok: true, message: 'Usuario registrado correctamente. Por favor, verifica tu correo electrónico.' }5Email ya registradouserData = { email: "existente@example.com", password: "Password123", displayName: "Usuario" }, donde el email ya existe en Firebase AuthRetorna { ok: false, errorMessage: 'El correo electrónico ya está registrado' }6Error en FirebaseuserData válido pero hay un error de conexión o cualquier otro error no específicoRetorna { ok: false, errorMessage: 'Error al registrar usuario. Inténtalo de nuevo más tarde.' }PCB-M-02 - Autenticación de usuarioNoPCB-M-02Nombre de la pruebaPCB-M-02 - Autenticación de usuarioMóduloAutenticaciónDescripcionVerificar inicio de sesión para acceder a la cuenta y funciones personalizadasCaso de prueba relacionadoHU-A02 - Como visitante quiero iniciar sesión para acceder a mi cuenta y funciones personalizadasRealizado porValentin Alejandro Perez ZuritaFecha14 de Abril del 2025Código Fuenteexport const startEmailSignIn = (email, password) => {  return async (dispatch) => {    dispatch(checkingCredentials());    try {      // 1) Sign in with email and password      const userCredential = await signInWithEmailAndPassword(FirebaseAuth, email, password);      const { uid, displayName, photoURL, email: userEmail } = userCredential.user;      const user = userCredential.user;      // 2) If email is not verified, send email verification      if (!user.emailVerified) {        await sendEmailVerification(user);                // 2.1) Sign out in Firebase Auth        await FirebaseAuth.signOut();        // 2.2) Sign out in Redux        dispatch(logout({ errorMessage: "Debes verificar tu correo. Te enviamos un nuevo enlace." }));        // 2.3) Return error message        return { ok: false, errorMessage: "Debes verificar tu correo. Te enviamos un nuevo enlace." };      }      // 3) If email is verified, dispatch login      dispatch(login({ uid, email: userEmail, displayName, photoURL }));      // 4) Return ok: true      return { ok: true };    } catch (error) {      console.error("Error en el inicio de sesión:", error.message);      // Dispatch logout      dispatch(logout({ errorMessage: "Error al iniciar sesión. Inténtalo de nuevo más tarde." }));      // Return error message      return { ok: false, errorMessage: "Error al iniciar sesión. Inténtalo de nuevo más tarde." };    }  };};Diagrama de flujoCálculo de la Complejidad CiclomáticaNodoPredicado1¿Credenciales válidas? 2¿Email verificado? 3¿Se produjo una excepción durante el inicio de sesión?MétodoResultadoNúmero de Regiones4Aristas - Nodos + 214 - 12 + 2 = 4Nodos Predicado + 13 + 1 = 4ConclusiónLa complejidad ciclomática es 4. Se deben identificar 4 caminos independientes para una cobertura de prueba completa.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Flujo principal exitoso (camino feliz)1 ? 2 ? 3(Sí) ? 4(Sí) ? 5 ? Fin2Email no verificado1 ? 2 ? 3(Sí) ? 4(No) ? 6 ? 7 ? 8 ? Fin3Credenciales inválidas1 ? 2 ? 3(No) ? 9 ? 10 ? Fin4Error inesperado (excepción)1 ? 2 ? 11 ? 12 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1Inicio de sesión exitosoemail: valentin.alejandro@outlook.compassword: Password123userCredential: { emailVerified: true }Se despacha login() con los datos del usuario superadmin.Retorna { ok: true }.El usuario accede a su perfil.2Email no verificadoemail: valentin.alejandro@nube.unadmexico.mxpassword: Password123userCredential: { emailVerified: false }Se envía nuevo correo de verificación, se cierra sesión, se despacha logout() con mensaje de error.Retorna { ok: false, errorMessage: "Debes verificar tu correo..." }.3Credenciales incorrectasemail: usuario.inexistente@example.compassword: PasswordIncorrectaSe lanza auth/user-not-found o auth/wrong-password, se despacha logout() con mensaje de error genérico.Retorna { ok: false, errorMessage: "Error al iniciar sesión..." }.4Error de conexiónemail: valentin-alejandro@hotmail.compassword: Password123Error simulado: auth/network-request-failedSe lanza excepción, se despacha logout() con mensaje genérico.Retorna { ok: false, errorMessage: "Error al iniciar sesión. Inténtalo de nuevo más tarde." }.PCB-M-03: CÁLCULO DE COSTO DE ENVÍONoPCB-M-03Nombre de la pruebaPCB-M-03 - Cálculo de costo de envíoMóduloCheckoutDescripciónVerificar el cálculo correcto del costo de envío según la dirección del cliente y el peso del pedidoCaso de prueba relacionadoHU-C03 - Como cliente quiero conocer el costo de envío basado en mi ubicación y peso de productos para planificar mi compraRealizado porValentin Alejandro Perez ZuritaFecha14 de Abril del 2025Código Fuente/** * Calcula el costo de envío basado en datos reales (versión refactorizada) * @param {Object} rule - Regla de envío * @param {Array} products - Productos a enviar * @returns {Object} - Información de costo y tiempo de entrega */const calculateShippingDetails = (rule, products) => {  // 1. Validación básica con valor predeterminado significativo  if (!rule || !products || products.length === 0) {    return {       cost: null,       minDays: null,       maxDays: null,       isFree: false,       isAvailable: false // Indica explícitamente que el envío no está disponible    };  }    // 2. Extraer datos usando funciones auxiliares  const subtotal = calculateSubtotal(products);  const totalWeight = calculateTotalWeight(products);    // 3. Calcular con la regla principal  let cost = extractCost(rule);  let isFree = isShippingFree(rule, subtotal);  let { minDays, maxDays } = extractDeliveryTimes(rule);    // 4. Aplicar reglas de paquetes  cost = applyPackageRules(cost, rule, products, totalWeight);    // 5. Usar opciones de mensajería si existen  if (hasShippingOptions(rule)) {    const bestOption = selectBestShippingOption(rule);    cost = extractCost(bestOption);    cost = applyPackageRules(cost, bestOption, products, totalWeight);        // Actualizar tiempos    const optionTimes = extractDeliveryTimes(bestOption);    minDays = optionTimes.minDays || minDays;    maxDays = optionTimes.maxDays || maxDays;  }    // 6. Envío gratuito si corresponde  if (isFree) {    cost = 0;  }    // 7. Normalizar tiempos de entrega  if (minDays !== null && maxDays !== null && maxDays < minDays) {    maxDays = minDays;  }    return {     cost,     minDays,     maxDays,     isFree,    isAvailable: true   };};/** * Calcula el subtotal de los productos * @param {Array} products - Lista de productos * @returns {number} - Subtotal */const calculateSubtotal = (products) => {  return products.reduce((sum, item) => {    const product = item.product || item;    const price = parseFloat(product.price || 0);    const quantity = parseInt(item.quantity || 1, 10);    return sum + (price * quantity);  }, 0);};/** * Calcula el peso total de los productos * @param {Array} products - Lista de productos * @returns {number} - Peso total */const calculateTotalWeight = (products) => {  return products.reduce((sum, item) => {    const product = item.product || item;    const weight = parseFloat(product.weight || 0);    const quantity = parseInt(item.quantity || 1, 10);    return sum + (weight * quantity);  }, 0);};/** * Extrae el costo base de una configuración * @param {Object} config - Configuración (regla o opción) * @returns {number} - Costo base */const extractCost = (config) => {  const cost = parseFloat(config.precio_base || config.base_price || config.precio || 0);  return cost >= 0 ? cost : 0; // Asegurar que no sea negativo};/** * Determina si se aplica envío gratis * @param {Object} rule - Regla de envío * @param {number} subtotal - Subtotal de la compra * @returns {boolean} - True si el envío es gratis */const isShippingFree = (rule, subtotal) => {  // Comprobar si está explícitamente configurado como gratis  if (rule.envio_gratis === true || rule.free_shipping === true) {    return true;  }    // Comprobar si se supera el monto mínimo para envío gratis  if (rule.envio_gratis_monto_minimo && subtotal >= parseFloat(rule.envio_gratis_monto_minimo)) {    return true;  }    return false;};/** * Extrae y normaliza los tiempos de entrega * @param {Object} config - Configuración (regla o opción) * @returns {Object} - Tiempos de entrega normalizados */const extractDeliveryTimes = (config) => {  let minDays = null;  let maxDays = null;    // Intentar obtener tiempo mínimo de entrega  if (config.tiempo_minimo !== undefined && config.tiempo_minimo !== null) {    minDays = parseInt(config.tiempo_minimo, 10);  } else if (config.min_days !== undefined && config.min_days !== null) {    minDays = parseInt(config.min_days, 10);  } else if (config.minDays !== undefined && config.minDays !== null) {    minDays = parseInt(config.minDays, 10);  }    // Intentar obtener tiempo máximo de entrega  if (config.tiempo_maximo !== undefined && config.tiempo_maximo !== null) {    maxDays = parseInt(config.tiempo_maximo, 10);  } else if (config.max_days !== undefined && config.max_days !== null) {    maxDays = parseInt(config.max_days, 10);  } else if (config.maxDays !== undefined && config.maxDays !== null) {    maxDays = parseInt(config.maxDays, 10);  }    // Intentar extraer de tiempo_entrega (formato "1-3 días" o "2 días")  if ((minDays === null || maxDays === null) && config.tiempo_entrega) {    const tiempoMatch = config.tiempo_entrega.match(/(\d+)[-\s]*(\d+)/);    if (tiempoMatch && tiempoMatch.length >= 3) {      if (minDays === null) minDays = parseInt(tiempoMatch[1], 10);      if (maxDays === null) maxDays = parseInt(tiempoMatch[2], 10);    } else if (config.tiempo_entrega.match(/(\d+)/)) {      // Si solo hay un número (ej: "2 días")      const singleMatch = config.tiempo_entrega.match(/(\d+)/);      const days = parseInt(singleMatch[1], 10);      if (minDays === null) minDays = days;      if (maxDays === null) maxDays = days;    }  }    return { minDays, maxDays };};/** * Aplica reglas de configuración de paquetes y calcula cargos extra * @param {number} baseCost - Costo base * @param {Object} config - Configuración (regla o opción) * @param {Array} products - Lista de productos * @param {number} totalWeight - Peso total de los productos * @returns {number} - Costo actualizado */const applyPackageRules = (baseCost, config, products, totalWeight) => {  let cost = baseCost;    // Si no hay configuración de paquetes, retornar costo sin cambios  if (!config.configuracion_paquetes) {    return cost;  }    const pkgConfig = config.configuracion_paquetes;    // Verificar si aplica cargo por peso extra  if (pkgConfig.peso_maximo_paquete !== undefined && pkgConfig.costo_por_kg_extra !== undefined) {    const maxWeight = parseFloat(pkgConfig.peso_maximo_paquete);    const extraWeightCost = parseFloat(pkgConfig.costo_por_kg_extra);        if (!isNaN(maxWeight) && !isNaN(extraWeightCost) && totalWeight > maxWeight) {      const extraWeight = totalWeight - maxWeight;      const extraCost = extraWeight * extraWeightCost;      cost += extraCost;    }  }    // Verificar si aplica cargo por producto extra  if (pkgConfig.maximo_productos_por_paquete !== undefined && pkgConfig.costo_por_producto_extra !== undefined) {    const maxProducts = parseInt(pkgConfig.maximo_productos_por_paquete, 10);    const extraProductCost = parseFloat(pkgConfig.costo_por_producto_extra);        if (!isNaN(maxProducts) && !isNaN(extraProductCost) && products.length > maxProducts) {      const extraProducts = products.length - maxProducts;      const extraCost = extraProducts * extraProductCost;      cost += extraCost;    }  }    return cost;};/** * Verifica si la regla tiene opciones de mensajería * @param {Object} rule - Regla de envío * @returns {boolean} - True si hay opciones de mensajería */const hasShippingOptions = (rule) => {  return Array.isArray(rule.opciones_mensajeria) && rule.opciones_mensajeria.length > 0;};/** * Selecciona la mejor opción de mensajería (más económica) * @param {Object} rule - Regla de envío * @returns {Object} - La opción más económica */const selectBestShippingOption = (rule) => {  // Ordenar por precio  const sortedOptions = [...rule.opciones_mensajeria].sort((a, b) =>     parseFloat(a.precio || 0) - parseFloat(b.precio || 0)  );    return sortedOptions[0]; // Retornar la opción más económica};Diagrama de flujoCálculo de la Complejidad CiclomáticaMétodoResultadoNúmero de Regiones4Aristas - Nodos + 217 - 15 + 2 = 4Nodos Predicado + 13 + 1 = 4ConclusiónLa complejidad ciclomática es 4, lo que implica que se deben identificar 4 caminos independientes dentro del grafo.NodoPredicado1¿rule y products válidos? (Nodo 1)2¿hasShippingOptions(rule)? (Nodo 7)3¿isFree es true? (Nodo 12)Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Validación inicial falla1(No) ? 2 ? Fin2Costo desde regla principal1(Sí) ? 3 ? 4 ? 5 ? 6 ? 7(No) ? 12(No) ? 14 ? 15 ? Fin3Costo con opciones de mensajería1(Sí) ? 3 ? 4 ? 5 ? 6 ? 7(Sí) ? 8 ? 9 ? 10 ? 11 ? 12(No) ? 14 ? 15 ? Fin4Envío gratuito1(Sí) ? 3 ? 4 ? 5 ? 6 ? 7(No) ? 12(Sí) ? 13 ? 14 ? 15 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1Regla o productos inválidosrule = null, products = []cost: null, minDays: null, maxDays: null, isFree: false, isAvailable: false2Costo desde regla principalrule.id = smb5ISAZrqo0DGREaVMC, precio_base = 150,peso_maximo_paquete = 5, costo_por_kg_extra = 30, producto = Canasta, weight = 7, quantity = 1cost: 210, minDays: null, maxDays: null, isFree: false, isAvailable: true3Costo con opciones de mensajeríarule.id = fyfkhfITejBjMASFCMZ2, precio_base = 200, opciones_mensajeria = [{precio: 80, tiempo_minimo: 2, tiempo_maximo: 5}, {precio: 150, tiempo_minimo: 1, tiempo_maximo: 2}], producto = Mermelada, weight = 2, quantity = 1cost: 80, minDays: 2, maxDays: 5, isFree: false, isAvailable: true4Envío gratuitorule.id = x8tRGxol2MOr8NMzeAPp,precio_base = 180, envio_gratis_monto_minimo = 1000, producto = Artesania, price = 600, quantity = 2cost: 0, minDays: null, maxDays: null, isFree: true, isAvailable: truePCB-M-04: PROCESO DE AUTORIZACIÓN BASADO EN ROLESNoPCB-M-04Nombre de la pruebaPCB-M-04 - Proceso de autorización basado en rolesMóduloAutenticaciónDescripciónVerificar que el sistema controle correctamente el acceso a áreas protegidas según el rol del usuario para garantizar la seguridad de la informaciónCaso de prueba relacionadoHU-AD01 - Como administrador quiero que el sistema permita el acceso a áreas administrativas solo a usuarios con rol de administrador o superadministrador, para mantener la seguridad del sistema.Realizado porValentin Alejandro Perez ZuritaFecha14 de Abril del 2025Código FuenteComponente RequireAdminAuth.jsx:import { useState, useEffect } from "react";import { Outlet, Navigate } from "react-router-dom";import LoadingSpinner from "../ui/LoadingSpinner";import { getUserRole } from "../../utils/authUtils";const RequireAdminAuth = () => {  const [role, setRole] = useState(null);  const [loading, setLoading] = useState(true);  useEffect(() => {    const checkUserRole = async () => {      try {        const userRole = await getUserRole();        setRole(userRole);      } catch (error) {        console.error("Error al verificar el rol:", error);        setRole("visitor");      } finally {        setLoading(false);      }    };    checkUserRole();  }, []);  if (loading) {    return <LoadingSpinner message="Verificando permisos..." />;  }  return (role === "admin" || role === "superadmin") ? (    <Outlet />  ) : (    <Navigate to="/admin/login" replace />  );};export default RequireAdminAuth;// src/utils/authUtils.jsimport { auth } from "../firebase/config";export const getUserRole = async () => {  try {    const currentUser = auth.currentUser;        if (!currentUser) {      return "visitor";    }        const tokenResult = await currentUser.getIdTokenResult();    return tokenResult.claims.role || "visitor";  } catch (error) {    console.error("Error al obtener el rol del usuario:", error);    return "visitor";  }};Diagrama de flujoCálculo de la Complejidad CiclomáticaNodoPredicado1¿rule y products válidos? (Nodo 1)2¿hasShippingOptions(rule)? (Nodo 7)3¿isFree es true? (Nodo 12)MétodoResultadoNúmero de Regiones3Aristas - Nodos + 27 - 6 + 2 = 3Nodos Predicado + 12 + 1 = 3ConclusiónLa complejidad ciclomática es 3, lo que implica que se deben identificar 3 caminos independientes dentro del diagrama.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Componente en estado de carga1 ? 2 ? 3 ? 4 ? 5(No) ? 8 ? 9 ? 10(Sí) ? 11 ? Fin2Usuario con rol de administrador1 ? 2 ? 3 ? 4 ? 5(No) ? 8 ? 9 ? 10(No) ? 12(Sí) ? 13 ? Fin3Usuario sin permisos administrativos1 ? 2 ? 3 ? 4 ? 5(No) ? 8 ? 9 ? 10(No) ? 12(No) ? 14 ? FinDerivación de Casos de PruebaCaminoCaso de pruebaDatos de entradaResultado esperado1Componente en estado de cargaloading = trueSe muestra el componente LoadingSpinner con el mensaje "Verificando permisos..." (Nodo 11)2Usuario con rol de administradorloading = false, role = "admin"Se renderiza el componente Outlet permitiendo acceso al contenido protegido (Nodo 13)3Usuario sin permisos administrativosloading = false, role = "visitor"Se renderiza el componente Navigate redirigiendo al usuario a "/admin/login" (Nodo 14)PCB-M-05: GESTIÓN DE CANTIDADES EN CARRITONoPCB-M-05Nombre de la pruebaPCB-M-05 - Gestión de cantidades en carritoMóduloShopDescripciónVerificar que el cliente pueda modificar correctamente las cantidades de los productos en su carrito para ajustar su pedido según sus necesidadesCaso de prueba relacionadoHU-C05 - Como cliente quiero modificar las cantidades de los productos en mi carrito para ajustar mi pedido según mis necesidadesRealizado porValentin Alejandro Perez ZuritaFecha15 de Abril del 2025Código Fuente/** * Incrementa la cantidad de un producto en el carrito * @param {string} productId - ID del producto * @returns {Promise<Object>} Resultado de la operación */const increaseQuantity = useCallback(async (productId) => {  if (!productId) return { success: false, message: 'ID de producto no válido' };  // Simplificamos el bloqueo para que no sea tan restrictivo  if (incrementLocks.current[productId]) {    // Si hay bloqueo, permitimos continuar pero lo registramos    console.log('Operación rápida detectada:', productId);  }  const item = items.find(item => item.id === productId);  if (!item) {    return { success: false, message: 'Producto no encontrado en el carrito' };  }  // Actualización optimista - actualizamos UI inmediatamente  dispatch(updateQuantity({ id: productId, quantity: item.quantity + 1 }));    // Marcar como bloqueado brevemente  incrementLocks.current[productId] = true;    // Validación en segundo plano sin bloquear UI  setTimeout(async () => {    try {      // Verificar stock en segundo plano      const currentStock = await getUpdatedProductStock(productId);            // Si excede el stock, revertir al stock máximo      if (item.quantity + 1 > currentStock) {        dispatch(updateQuantity({ id: productId, quantity: currentStock }));        console.warn(`Cantidad ajustada a stock disponible (${currentStock})`);      }            // Sincronizar con el servidor si necesario      if (uid) dispatch(syncCartWithServer());    } catch (error) {      console.error('Error en validación de stock:', error);    } finally {      // Liberar bloqueo rápidamente      incrementLocks.current[productId] = false;    }  }, 300); // Retraso mínimo para mejor UX  return { success: true };}, [dispatch, items, uid, getUpdatedProductStock]);/** * Decrementa la cantidad de un producto en el carrito * @param {string} productId - ID del producto * @returns {Object} Resultado de la operación */const decreaseQuantity = useCallback((productId) => {  if (!productId) return { success: false };  // Simplificamos el bloqueo para permitir operaciones rápidas  if (incrementLocks.current[productId]) {    console.log('Operación rápida detectada (decremento):', productId);  }  const item = items.find(item => item.id === productId);  if (!item || item.quantity <= 1) {    return { success: false };  }  // Actualización optimista - actualizamos UI inmediatamente  dispatch(updateQuantity({ id: productId, quantity: item.quantity - 1 }));    // Marcar como bloqueado brevemente  incrementLocks.current[productId] = true;    // Sincronizar con el servidor en segundo plano  setTimeout(() => {    if (uid) dispatch(syncCartWithServer());    // Liberar bloqueo rápidamente    incrementLocks.current[productId] = false;  }, 300);    return { success: true };}, [dispatch, items, uid]);Diagrama de flujoCálculo de la Complejidad CiclomáticaFunciónNúmero de RegionesAristas - Nodos + 2Nodos Predicado + 1Complejidad CiclomáticaincreaseQuantity520 - 17 + 2 = 54 + 1 = 55decreaseQuantity313 - 12 + 2 = 32 + 1 = 33Determinación del Conjunto Básico de Caminos IndependientesTabla de Caminos – increaseQuantityNºDescripciónSecuencia de nodos1Flujo feliz - producto incrementado con éxito y stock suficiente (usuario autenticado)1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6 ? 7 ? 9 ? 10(No) ? 12 ? 13(Sí) ? 14 ? 16 ? 17 ? Fin2Flujo alternativo - stock insuficiente (usuario autenticado)1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6 ? 7 ? 9 ? 10(Sí) ? 11 ? 13(Sí) ? 14 ? 16 ? 17 ? Fin3Flujo alternativo - usuario no autenticado1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6 ? 7 ? 9 ? 10(No) ? 12 ? 13(No) ? 15 ? 16 ? 17 ? Fin4Error - ID de producto inválido1(No) ? Fin5Error - Producto no encontrado en carrito1 ? 2 ? 3 ? 4(No) ? FinTabla de Caminos – decreaseQuantityNºDescripciónSecuencia de nodos1Flujo feliz - decremento exitoso (usuario autenticado)1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6 ? 7 ? 8(Sí) ? 9 ? 11 ? 12 ? Fin2Flujo alternativo - usuario no autenticado1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6 ? 7 ? 8(No) ? 10 ? 11 ? 12 ? Fin3Error - ID inválido o cantidad ≤ 11(No) ? Fin  o  1 ? 2 ? 3 ? 4(No) ? FinDerivación de Casos de PruebaCasos de Prueba – increaseQuantityCaminoCaso de PruebaDatos de EntradaResultado Esperado1Incremento exitoso con usuario autenticadoproductId: "DRIbOsoP1PAuq7sOEXFz"item: { id: "DRIbOsoP1PAuq7sOEXFz", quantity: 2, stock: 97 }uid: "user456"currentStock: 97Se incrementa la cantidad a 3 inmediatamente en la UI. Se obtiene el stock real (97). Se sincroniza con el servidor. Retorna { success: true }.2Incremento con ajuste de stock (usuario autenticado)productId: "DRIbOsoP1PAuq7sOEXFz"item: { id: "DRIbOsoP1PAuq7sOEXFz", quantity: 9, stock: 97 }uid: "user456"currentStock: 9Se incrementa a 10 en UI, pero se ajusta a 9 por stock real insuficiente. Se sincroniza con el servidor. Retorna { success: true }.3Incremento exitoso con usuario no autenticadoproductId: "DRIbOsoP1PAuq7sOEXFz"item: { id: "DRIbOsoP1PAuq7sOEXFz", quantity: 2, stock: 97 }uid: nullcurrentStock: 97Se incrementa a 3 en la UI. Se obtiene el stock real (97). No se sincroniza con el servidor. Retorna { success: true }.4Error por ID de producto inválidoproductId: nullRetorna inmediatamente { success: false, message: "ID de producto no válido" } sin realizar ninguna operación en el carrito.5Error por producto no encontrado en carritoproductId: "prod999"items: [{ id: "DRIbOsoP1PAuq7sOEXFz", quantity: 2, stock: 97 }]Retorna { success: false, message: "Producto no encontrado en el carrito" } sin realizar ninguna operación en el carrito.Casos de Prueba – increaseQuantityCaminoCaso de PruebaDatos de EntradaResultado Esperado1Decremento exitoso con usuario autenticadoproductId: "5cIy1KR7s15VFdHqlPdJ"item: { id: "5cIy1KR7s15VFdHqlPdJ", quantity: 3 }uid: "user456"Se decrementa la cantidad a 2 inmediatamente en la UI. Se sincroniza el carrito con el servidor. Retorna { success: true }.2Decremento exitoso con usuario no autenticadoproductId: "5cIy1KR7s15VFdHqlPdJ"item: { id: "5cIy1KR7s15VFdHqlPdJ", quantity: 3 }uid: nullSe decrementa la cantidad a 2 inmediatamente en la UI. No se sincroniza con el servidor por falta de autenticación. Retorna { success: true }.3Error por ID inválidoproductId: nullRetorna inmediatamente { success: false } sin realizar ninguna operación en el carrito.4Error por cantidad mínimaproductId: "5cIy1KR7s15VFdHqlPdJ"item: { id: "5cIy1KR7s15VFdHqlPdJ", quantity: 1 }Retorna { success: false } sin decrementar la cantidad por estar ya en el mínimo permitido (1).PCB-M-06: FILTRADO DE PRODUCTOS POR PRECIONoPCB-M-06Nombre de la pruebaPCB-M-06 - Filtrado de productos por precioMóduloShopDescripciónVerificar que el cliente pueda filtrar los productos por precio y otras características para encontrar más fácilmente los productos que le interesan.Caso de prueba relacionadoHU-S03 - Como cliente quiero filtrar los productos por precio y otras características para encontrar más fácilmente los productos que me interesanRealizado porValentin Alejandro Perez ZuritaFecha15 de Abril del 2025Código Fuente/** * Función que filtra productos según diferentes criterios * Parte del hook useProducts en src/modules/shop/hooks/useProducts.js */const filteredProducts = useMemo(() => {  // Si hay carga o error, devolver un array vacío  if (loading || error) return [];  let result = [...originalProducts];  // Filtrar por término de búsqueda (nombre o categoría)  if (searchTerm.trim() !== "") {    const normalizedSearchTerm = searchTerm.toLowerCase().trim();    result = result.filter((prod) =>       // Buscar en el nombre del producto      (prod.name && prod.name.toLowerCase().includes(normalizedSearchTerm)) ||       // Buscar en la categoría del producto      (prod.category && prod.category.toLowerCase().includes(normalizedSearchTerm))    );  }  // Filtrar por categoría  if (selectedCategory) {    result = result.filter((prod) => prod.category?.toLowerCase() === selectedCategory.toLowerCase());  }  // Ordenar por precio  switch (priceOrder) {    case "Menor a Mayor":      result.sort((a, b) => a.price - b.price);      break;    case "Mayor a Menor":      result.sort((a, b) => b.price - a.price);      break;    case "Destacados":      result = result.filter((prod) => prod.featured);      break;    default:      break;  }  // Devolver los productos filtrados  return result;}, [originalProducts, loading, error, searchTerm, selectedCategory, priceOrder]);Diagrama de flujoCálculo de la Complejidad CiclomáticaNodoDescripción1¿loading?2¿searchTerm no vacío?3¿selectedCategory definido?4switch (priceOrder) con 4 casosMétodoResultadoNúmero de Regiones5Aristas - Nodos + 217 - 14 + 2 = 5Nodos Predicado + 14 + 1 = 5ConclusiónLa complejidad ciclomática es 5, lo que implica que se deben identificar 5 caminos independientes dentro del grafo.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Carga o error activo1(Sí) ? 2 ? Fin2Sin filtros ni ordenamiento1(No) ? 3 ? 4(No) ? 7(No) ? 9(default) ? 13 ? 14 ? Fin3Con búsqueda y ordenamiento ascendente1(No) ? 3 ? 4(Sí) ? 5 ? 6 ? 7(No) ? 9(Menor a Mayor) ? 10 ? 14 ? Fin4Con categoría y ordenamiento descendente1(No) ? 3 ? 4(No) ? 7(Sí) ? 8 ? 9(Mayor a Menor) ? 11 ? 14 ? Fin5Filtro por destacados1(No) ? 3 ? 4(No) ? 7(No) ? 9(Destacados) ? 12 ? 14 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1Loading o error activoloading = trueerror = nulloriginalProducts = [{ name: "Cerveza Local", price: 50 }, { name: "Gorro de Calabaza", price: 250 }]Retorna un array vacío [].2Sin filtros ni ordenamientoloading = falseerror = nulloriginalProducts = [{ name: "Cerveza Local", price: 50 }, { name: "Cafe", price: 199 }]searchTerm = ""selectedCategory = ""priceOrder = ""Retorna copia sin modificaciones: [{ name: "Cerveza Local", price: 50 }, { name: "Cafe", price: 199 }].3Búsqueda y orden ascendente por nombreloading = falseerror = nulloriginalProducts = [{ name: "Canasta", price: 300 }, { name: "Cafe", price: 199 }, { name: "Cerveza Local", price: 50 }]searchTerm = "ca"selectedCategory = ""priceOrder = "Menor a Mayor"Retorna: [{ name: "Cerveza Local", price: 50 }, { name: "Cafe", price: 199 }, { name: "Canasta", price: 300 }].4Filtro por categoría y orden descendenteloading = falseerror = nulloriginalProducts = [{ name: "Gorro de Calabaza", category: "Appareal", price: 250 }, { name: "Artesania", category: "Appareal", price: 997 }]searchTerm = "selectedCategory = "Appareal"priceOrder = "Mayor a Menor"Retorna: [{ name: "Artesania", price: 997 }, { name: "Gorro de Calabaza", price: 250 }].5Filtro por destacadosloading = falseerror = nulloriginalProducts = [{ name: "Mermelada", featured: true, price: 90 }, { name: "Queso artesanal", featured: false, price: 199 }, { name: "Gotas naturistas de energía", featured: true, price: 399 }]searchTerm = "selectedCategory = "priceOrder = "Destacados"Retorna: [{ name: "Mermelada", price: 90 }, { name: "Gotas naturistas de energía", price: 399 }].PCB-M-07: GESTIÓN DE INVENTARIO ADMINISTRATIVONoPCB-M-07Nombre de la pruebaPCB-M-07 - Gestión de inventario administrativoMóduloAdministraciónDescripciónVerificar que el administrador pueda actualizar el stock de productos correctamente y que el sistema muestre alertas cuando el inventario esté por debajo del umbral establecido.Caso de prueba relacionadoHU-AD03 - Como administrador quiero actualizar el stock de productos y recibir alertas cuando el inventario esté bajo para mantener control efectivo del inventarioRealizado porValentin Alejandro Perez ZuritaFecha15 de Abril del 2025Código Fuente/** * Función para actualizar el inventario después de una compra exitosa * Extracto de functions/payment/simulateOxxOPayment.js */async function updateInventory(items) {  // Obtener un batch para hacer múltiples actualizaciones  const batch = admin.firestore().batch();  // Iterar sobre cada producto en la orden  for (const item of items) {    const productRef = admin.firestore().collection('products').doc(item.id);    const productSnap = await productRef.get();    if (productSnap.exists) {      const product = productSnap.data();      const newStock = Math.max(0, (product.stock || 0) - item.quantity);      // Verificar si es necesario emitir alerta de stock      const needsAlert = product.stock > 0 && newStock <= (product.alertThreshold || 5);            // Actualizar el stock      batch.update(productRef, {        stock: newStock,        updatedAt: admin.firestore.FieldValue.serverTimestamp()      });            // Si es necesario, agregar notificación de stock bajo      if (needsAlert) {        const alertsRef = admin.firestore().collection('inventory_alerts');        const alertData = {          productId: item.id,          productName: product.name || 'Producto sin nombre',          previousStock: product.stock,          currentStock: newStock,          threshold: product.alertThreshold || 5,          createdAt: admin.firestore.FieldValue.serverTimestamp(),          status: 'pending',          type: 'low_stock'        };                batch.set(alertsRef.doc(), alertData);                // Intentar enviar notificación a administradores        try {          await sendLowStockNotification(alertData);        } catch (notificationError) {          console.error('Error enviando notificación de stock bajo:', notificationError);          // Continuar a pesar del error en la notificación        }      }    }  }  // Ejecutar todas las actualizaciones en un batch  try {    await batch.commit();    return { success: true };  } catch (batchError) {    console.error('Error actualizando inventario:', batchError);    return { success: false, error: batchError.message };  }}/** * Función auxiliar para enviar notificaciones de stock bajo */async function sendLowStockNotification(alertData) {  try {    // Obtener administradores que deban recibir notificaciones    const adminsQuery = await admin.firestore()      .collection('users')      .where('role', 'in', ['admin', 'superadmin'])      .where('settings.notifications.lowStock', '==', true)      .limit(10)      .get();        if (adminsQuery.empty) {      console.log('No hay administradores configurados para recibir alertas');      return false;    }        // Preparar mensaje    const message = {      subject: `Alerta de stock bajo: ${alertData.productName}`,      body: `El producto "${alertData.productName}" ha bajado a ${alertData.currentStock} unidades (por debajo del umbral de ${alertData.threshold})`,      data: {        type: 'low_stock',        productId: alertData.productId,        severity: alertData.currentStock === 0 ? 'critical' : 'warning'      }    };        // Enviar notificación a cada administrador    const promises = [];    adminsQuery.forEach(adminDoc => {      const adminData = adminDoc.data();      if (adminData.email) {        promises.push(          sendEmail({            to: adminData.email,            subject: message.subject,            html: `<p>${message.body}</p><p><a href="${process.env.ADMIN_URL}/inventory">Ver inventario</a></p>`          })        );      }    });        await Promise.all(promises);    return true;  } catch (error) {    console.error('Error en notificación de stock bajo:', error);    return false;  }}Diagrama de flujoCálculo de la Complejidad CiclomáticaNodoDescripción1¿Quedan productos? (loop while)2¿Producto existe? (Nodo 5)3¿stock > 0 && newStock <= threshold? (Nodo 8)4¿Requiere alerta? (Nodo 12)5¿Error en notificación? (Nodo 15)6¿Error en batch.commit? (Nodo 21)MétodoResultadoNúmero de Regiones7Aristas - Nodos + 228 - 23 + 2 = 7Nodos Predicado + 16 + 1 = 7ConclusiónLa complejidad ciclomática es 7, lo que implica que se deben identificar 7 caminos independientes dentro del grafo.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1No hay productos (lista vacía)1 ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin2Producto no existe1 ? 2 ? (loop=Sí) ? 3 ? 4 ? 5(No) ? 19 ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin3Producto sin alerta de stock1 ? 2 ? (loop=Sí) ? 3 ? 4 ? 5(Sí) ? 6 ? 7 ? 8(No) ? 10 ? 11 ? 12(No) ? 18 ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin4Producto con alerta de stock, notificación exitosa1 ? 2 ? (loop=Sí) ? 3 ? 4 ? 5(Sí) ? 6 ? 7 ? 8(Sí) ? 9 ? 11 ? 12(Sí) ? 13 ? 14 ? 15(No) ? 17 ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin5Producto con alerta de stock, error en notificación1 ? 2 ? (loop=Sí) ? 3 ? 4 ? 5(Sí) ? 6 ? 7 ? 8(Sí) ? 9 ? 11 ? 12(Sí) ? 13 ? 14 ? 15(Sí) ? 16 ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin6Múltiples productos exitosos1 ? 2 ? (loop=Sí) ? ... ? 2 ? (loop=Sí) ? ... ? 2 ? (loop=No) ? 20 ? 21(No) ? 23 ? Fin7Error en commit del batch1 ? 2 ? (loop=Sí) ? ... ? 2 ? (loop=No) ? 20 ? 21(Sí) ? 22 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1No hay productositems = []Batch vacío, commit exitoso, retorna { success: true }2Producto no existeitems = [{ id: "producto_inexistente", quantity: 2 }]productSnap.exists = falseNo se realiza actualización del producto inexistente, commit exitoso, retorna { success: true }3Producto sin alerta de stockitems = [{ id: "5cIy1KR7s15VFdHqlPdJ", quantity: 1 }]productSnap = { exists: true, stock: 48, alertThreshold: 5 }Stock actualizado a 47, sin alerta generada, commit exitoso, retorna { success: true }4Producto con alerta, notificación OKitems = [{ id: "tamNmyF8YaSXpyH4vNcw", quantity: 1 }]productSnap = { exists: true, stock: 4, name: "Queso artesanal", alertThreshold: 5 }adminsQuery = [{ email: "admin@example.com" }]Stock actualizado a 3, alerta generada, notificación enviada correctamente, commit exitoso, retorna { success: true }5Producto con alerta, error notificaciónitems = [{ id: "tamNmyF8YaSXpyH4vNcw", quantity: 1 }]productSnap = { exists: true, stock: 4, name: "Queso artesanal", alertThreshold: 5 } sendLowStockNotification lanza errorStock actualizado a 3, alerta generada, error en notificación registrado pero no bloquea, commit exitoso, retorna { success: true }6Múltiples productos exitosositems = [{ id: "4hjaD5ITZWkhicgPr0jE", quantity: 1 }, { id: "5cIy1KR7s15VFdHqlPdJ", quantity: 2 }]Ambos productos existenStock de ambos productos actualizado (a 28 y 46 respectivamente), commit exitoso, retorna { success: true }7Error en commit del batchitems = [{ id: "4hjaD5ITZWkhicgPr0jE", quantity: 1 }]batch.commit lanza errorSe registra el error, retorna { success: false, error: "Mensaje de error" }PCB-M-08: PROCESAMIENTO DE CONFIRMACIÓN DE PAGONoPCB-M-08Nombre de la pruebaPCB-M-08 - Procesamiento de confirmación de pagoMóduloCheckoutDescripciónVerificar que el sistema procese correctamente la confirmación de pago y notifique al cliente para asegurar la finalización exitosa de su compra.Caso de prueba relacionadoHU-C08 - Como cliente quiero recibir confirmación cuando mi pago ha sido procesado exitosamente para tener seguridad de mi compraRealizado porValentin Alejandro Perez ZuritaFecha15 de Abril del 2025Código Fuente/** * Cloud Function para confirmar el pago de una orden * Extracto de functions/payment/paymentIntents.js */exports.confirmOrderPayment = onCall({  region: "us-central1",  secrets: [stripeSecretParam]}, async (request) => {  // Verificar autenticación  if (!request.auth) {    throw new HttpsError(      "unauthenticated",      "Debes iniciar sesión para confirmar pagos"    );  }  const { orderId, paymentIntentId } = request.data;  // Validar datos  if (!orderId) {    throw new HttpsError(      "invalid-argument",      "Se requiere un ID de orden"    );  }  if (!paymentIntentId) {    throw new HttpsError(      "invalid-argument",      "Se requiere un ID de Payment Intent"    );  }  try {    // Inicializar Stripe con el secreto    const stripe = require("stripe")(stripeSecretParam.value());    // Obtener la orden    const orderRef = admin.firestore().collection('orders').doc(orderId);    const orderSnap = await orderRef.get();    if (!orderSnap.exists) {      throw new Error("La orden no existe");    }    const orderData = orderSnap.data();    // Verificar que la orden pertenezca al usuario autenticado    if (orderData.userId !== request.auth.uid) {      throw new HttpsError(        "permission-denied",        "No tienes permiso para confirmar esta orden"      );    }    // Consultar el estado del Payment Intent en Stripe    const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);    // Actualizar el registro de Payment Intent    await updatePaymentIntentStatus(paymentIntentId, paymentIntent.status);    // Determinar el estado de la orden basado en el resultado del pago    let orderStatus;    let paymentStatus;    switch (paymentIntent.status) {      case 'succeeded':        orderStatus = 'processing'; // La orden pasa a procesamiento        paymentStatus = 'succeeded';        break;      case 'processing':        orderStatus = 'pending';        paymentStatus = 'processing';        break;      case 'requires_payment_method':        orderStatus = 'payment_failed';        paymentStatus = 'failed';        break;      case 'requires_action':        orderStatus = 'pending';        paymentStatus = 'requires_action';        break;      case 'canceled':        orderStatus = 'cancelled';        paymentStatus = 'cancelled';        break;      default:        orderStatus = 'pending';        paymentStatus = paymentIntent.status;    }    // Actualizar la orden con el estado actual    await orderRef.update({      status: orderStatus,      'payment.status': paymentStatus,      'payment.lastPaymentIntentStatus': paymentIntent.status,      'payment.lastUpdated': admin.firestore.FieldValue.serverTimestamp(),      updatedAt: admin.firestore.FieldValue.serverTimestamp()    });    // Si el pago fue exitoso, actualizar el inventario    if (paymentStatus === 'succeeded') {      try {        await updateInventory(orderData.items);      } catch (inventoryError) {        console.error("Error actualizando inventario:", inventoryError);        // No interrumpir el flujo si falla la actualización de inventario      }      // Enviar email de confirmación      try {        await sendOrderConfirmationEmail(orderId);      } catch (emailError) {        console.error("Error enviando email de confirmación:", emailError);        // No interrumpir si falla el envío del email      }    }    return {      success: true,      orderStatus,      paymentStatus,      paymentIntent: {        id: paymentIntent.id,        status: paymentIntent.status,        clientSecret: paymentIntent.client_secret      }    };  } catch (error) {    console.error("Error confirmando pago:", error);    throw new HttpsError("internal", error.message);  }});Diagrama de flujoCálculo de la Complejidad CiclomáticaNodo PredicadoDescripción1¿Quedan productos? (loop while)2¿Producto existe? (Nodo 5)3¿stock > 0 && newStock <= threshold? (Nodo 8)4¿Requiere alerta? (Nodo 12)5¿Error en notificación? (Nodo 15)6¿Error en batch.commit? (Nodo 21)MétodoResultadoNúmero de Regiones7Aristas - Nodos + 228 - 23 + 2 = 7Nodos Predicado + 16 + 1 = 7ConclusiónLa complejidad ciclomática es 7, lo que implica que se deben identificar 7 caminos independientes dentro del grafo.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Error: usuario no autenticado1(No) ? 2 ? Fin2Error: orderId inválido1(Sí) ? 3 ? 4(No) ? 5 ? Fin3Error: paymentIntentId inválido1(Sí) ? 3 ? 4(Sí) ? 6(No) ? 7 ? Fin4Error: orden no existe1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(No) ? 11 ? Fin5Orden no pertenece al usuario1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(No) ? 13 ? Fin6Pago exitoso (succeeded) sin errores1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(Sí) ? 14 ? 15 ? 16 ? 17(succeeded) ? 18 ? 24 ? 25(Sí) ? 26 ? 27(No) ? 29 ? 30(No) ? 33 ? Fin7Pago en procesamiento (processing)1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(Sí) ? 14 ? 15 ? 16 ? 17(processing) ? 19 ? 24 ? 25(No) ? 32 ? 33 ? Fin8Pago fallido (requires_payment_method)1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(Sí) ? 14 ? 15 ? 16 ? 17(requires_payment_method) ? 20 ? 24 ? 25(No) ? 32 ? 33 ? Fin9Pago exitoso con error en inventario1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(Sí) ? 14 ? 15 ? 16 ? 17(succeeded) ? 18 ? 24 ? 25(Sí) ? 26 ? 27(Sí) ? 28 ? 29 ? 30(No) ? 33 ? Fin10Pago exitoso con error en email1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? 9 ? 10(Sí) ? 12(Sí) ? 14 ? 15 ? 16 ? 17(succeeded) ? 18 ? 24 ? 25(Sí) ? 26 ? 27(No) ? 29 ? 30(Sí) ? 31 ? 33 ? Fin11Error inesperado (excepción)1(Sí) ? 3 ? 4(Sí) ? 6(Sí) ? 8 ? (excepción) ? 34 ? 35 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1Usuario no autenticadorequest.auth = nullSe lanza HttpsError con código "unauthenticated" y mensaje "Debes iniciar sesión para confirmar pagos"2orderId inválidorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }request.data = { orderId: null, paymentIntentId: 'pi_123' }Se lanza HttpsError con código "invalid-argument" y mensaje "Se requiere un ID de orden"3paymentIntentId inválidorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }request.data = { orderId: '0CtVdxOrrU6DuWAWqaoD', paymentIntentId: null }Se lanza HttpsError con código "invalid-argument" y mensaje "Se requiere un ID de Payment Intent"4Orden no existerequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: 'ZZZZnotfound', paymentIntentId: 'pi_123' }orderSnap.exists = falseSe lanza Error con mensaje "La orden no existe"5Orden no pertenece al usuariorequest.auth = { uid: 'GuqA7YjmF8V4Ck6G79doHrA80oK2' }, request.data = { orderId: '0CtVdxOrrU6DuWAWqaoD', paymentIntentId: 'pi_123' }, orderData.userId != uidSe lanza HttpsError con código "permission-denied" y mensaje "No tienes permiso para confirmar esta orden"6Pago exitoso sin erroresrequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: '225v7QZcFYbU917w8a6Q', paymentIntentId: 'pi_123' }, paymentIntent.status = "succeeded"Se actualiza la orden a "processing", se actualiza inventario, se envía email, y se retorna { success: true }7Pago en procesamientorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: '4vDuJpwhv243IefbPueg', paymentIntentId: 'pi_123' }, status = "processing"Se actualiza la orden a "pending", no se actualiza inventario ni se envía email, retorna { success: true }8Pago fallidorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: 'BXmMUkdC6dOlFGCwOt5e', paymentIntentId: 'pi_123' }, status = "requires_payment_method"Se actualiza la orden a "payment_failed", no se actualiza inventario ni se envía email, retorna { success: true }9Pago exitoso con error inventariorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: '4K06Ks91dP3b73D1zVXw', paymentIntentId: 'pi_123' }, updateInventory lanza errorSe registra error de inventario, se continúa, se envía email y retorna { success: true }10Pago exitoso con error en emailrequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: '3THnxjfiNkdYi4Wbdpjf', paymentIntentId: 'pi_123' }, error en emailSe registra error en envío de email pero se continúa y retorna { success: true }11Error inesperadorequest.auth = { uid: 'MNQKuTrk7cTNUm9NDQRalyHrRL92' }, request.data = { orderId: 'FPmnBbHmH5TwkrARmfTB', paymentIntentId: 'pi_123' }, Stripe lanza error inesperadoSe lanza HttpsError con código "internal"PCB-M-09: BÚSQUEDA AVANZADA DE PRODUCTOSNoPCB-M-10Nombre de la pruebaPCB-M-10 - Actualización de estados de pedidoMóduloAdministraciónDescripciónVerificar que el sistema permita al administrador actualizar correctamente el estado de los pedidos, gestionando el ciclo de vida de las órdenes y manteniendo informados a los clientes.Caso de prueba relacionadoHU-AD05 - Como administrador quiero actualizar el estado de los pedidos para gestionar el ciclo de vida de las órdenes y mantener informados a los clientesRealizado porValentin Alejandro Perez ZuritaFecha16 de Abril del 2025Código Fuente/** * Actualiza el estado de un pedido y registra el cambio * Extracto de src/modules/admin/orders/services/orderAdminService.js *  * @param {string} orderId - ID del pedido * @param {string} newStatus - Nuevo estado * @param {string} adminId - ID del administrador * @param {string} notes - Notas sobre el cambio (opcional) * @returns {Promise<Object>} - Resultado de la operación */export const updateOrderStatus = async (orderId, newStatus, adminId, notes = '') => {  try {    if (!orderId || !newStatus || !adminId) {      return { ok: false, error: 'Faltan datos requeridos' };    }    // Obtener el pedido actual    const result = await getOrderById(orderId);    if (!result.ok) {      return result;    }    const order = result.data;    const currentStatus = order.status;    // Verificar si el cambio de estado es válido según el flujo de trabajo    const isValidTransition = validateStatusTransition(currentStatus, newStatus);    if (!isValidTransition) {      return {         ok: false,         error: `Transición no válida: ${currentStatus} ? ${newStatus}`       };    }    // Crear registro histórico del cambio    const statusChange = {      from: currentStatus,      to: newStatus,      changedAt: new Date(),      changedBy: adminId,      notes    };    // Actualizar el pedido    const orderRef = doc(FirebaseDB, ORDERS_COLLECTION, orderId);    await updateDoc(orderRef, {      status: newStatus,      statusHistory: [...(order.statusHistory || []), statusChange],      updatedAt: serverTimestamp()    });    // Si el cambio es a "shipped", verificar si hay información de envío    if (newStatus === 'shipped' && (!order.shipping || !order.shipping.trackingInfo)) {      // Registrar una advertencia interna      console.warn(`Orden ${orderId} marcada como enviada sin información de seguimiento`);    }    // Si el cambio es a estado "completed" o "cancelled", notificar al cliente    if (newStatus === 'completed' || newStatus === 'cancelled') {      try {        await sendOrderStatusNotification(order.userId, orderId, newStatus, notes);      } catch (notificationError) {        console.error('Error al enviar notificación:', notificationError);        // No interrumpir el flujo si hay error en la notificación      }    }    return { ok: true, error: null };  } catch (error) {    console.error('Error al actualizar estado del pedido:', error);    return { ok: false, error: error.message };  }};/** * Valida si la transición de estado es permitida según el flujo de trabajo * @param {string} currentStatus - Estado actual * @param {string} newStatus - Nuevo estado * @returns {boolean} - true si la transición es válida */const validateStatusTransition = (currentStatus, newStatus) => {  // Definir transiciones permitidas  const allowedTransitions = {    'pending': ['processing', 'cancelled'],    'processing': ['shipped', 'cancelled'],    'shipped': ['delivered', 'cancelled'],    'delivered': ['completed', 'returned'],    'completed': ['returned'],    'returned': [],    'cancelled': ['pending'] // Solo admins pueden reactivar  };  // Verificar si la transición está permitida  return allowedTransitions[currentStatus]?.includes(newStatus) || false;};Diagrama de flujoCálculo de la Complejidad CiclomáticaNodoDescripción1¿onlyActive? (Nodo 4)2¿onlyFeatured? (Nodo 6)3¿category especificada? (Nodo 8)4¿shippingRuleId especificado? (Nodo 10)5¿query de texto especificada? (Nodo 16)6¿Se produce una excepción en el bloque try-catch? (entre nodo 1 y nodo 20)CampoResultadoNúmero de Regiones7Aristas - Nodos + 226 - 21 + 2 = 7Nodos Predicado + 16 + 1 = 7ConclusiónLa complejidad ciclomática es 7, lo que implica que se deben identificar 7 caminos independientes dentro del diagrama.Determinación del Conjunto Básico de Caminos IndependientesNºDescripciónSecuencia de nodos1Error en ejecución1 ? (excepción) ? 20 ? 21 ? Fin2Búsqueda sin filtros ni texto (solo activos por defecto)1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(No) ? 8(No) ? 10(No) ? 12 ? 13 ? 14 ? 15 ? 16(No) ? 19 ? Fin3Búsqueda de productos destacados1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(Sí) ? 7 ? 8(No) ? 10(No) ? 12 ? 13 ? 14 ? 15 ? 16(No) ? 19 ? Fin4Búsqueda por categoría1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(No) ? 8(Sí) ? 9 ? 10(No) ? 12 ? 13 ? 14 ? 15 ? 16(No) ? 19 ? Fin5Búsqueda por regla de envío1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(No) ? 8(No) ? 10(Sí) ? 11 ? 12 ? 13 ? 14 ? 15 ? 16(No) ? 19 ? Fin6Búsqueda con texto, sin filtros adicionales1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(No) ? 8(No) ? 10(No) ? 12 ? 13 ? 14 ? 15 ? 16(Sí) ? 17 ? 18 ? 19 ? Fin7Búsqueda combinada (texto + filtros)1 ? 2 ? 3 ? 4(Sí) ? 5 ? 6(Sí) ? 7 ? 8(Sí) ? 9 ? 10(No) ? 12 ? 13 ? 14 ? 15 ? 16(Sí) ? 17 ? 18 ? 19 ? FinDerivación de Casos de PruebaCaminoCaso de PruebaDatos de EntradaResultado Esperado1Error en la consultaFirestore arroja error durante la ejecuciónSe registra el error y retorna array vacío []2Solo productos activoscriteria = { onlyActive: true }Retorna array con todos los productos activos, sin filtro adicional3Solo productos destacadoscriteria = { onlyActive: true, onlyFeatured: true }Retorna array con productos que son activos y destacados4Filtro por categoríacriteria = { category: 'Productos Naturistas' }Retorna array con productos activos de la categoría ‘Productos Naturistas’5Filtro por regla de envíocriteria = { shippingRuleId: 'x8tRGxol2MOr8NMzeAPp' }Retorna array con productos activos que usan la regla de envío ‘x8tRGxol2MOr8NMzeAPp’6Búsqueda por textocriteria = { query: 'miel' }Retorna array con productos activos cuyo nombre o descripción contiene ‘miel’7Búsqueda combinadacriteria = { query: 'canasta', onlyFeatured: true, category: 'Vegetales' }Retorna array con productos activos, destacados, de categoría ‘Vegetales’ y que contengan ‘canasta’ en nombre o descripciónPCB-M-10: ACTUALIZACIÓN DE ESTADOS DE PEDIDONoPCB-M-10Nombre de la pruebaPCB-M-10 - Actualización de estados de pedidoMóduloAdministraciónDescripciónVerificar que el sistema permita al administrador actualizar correctamente el estado de los pedidos, gestionando el ciclo de vida de las órdenes y manteniendo informados a los clientes.Caso de prueba relacionadoHU-AD05 - Como administrador quiero actualizar el estado de los pedidos para gestionar el ciclo de vida de las órdenes y mantener informados a los clientesRealizado porValentin Alejandro Perez ZuritaFecha16 de Abril del 2025Código Fuente/** * Actualiza el estado de un pedido y registra el cambio * Extracto de src/modules/admin/orders/services/orderAdminService.js *  * @param {string} orderId - ID del pedido * @param {string} newStatus - Nuevo estado * @param {string} adminId - ID del administrador * @param {string} notes - Notas sobre el cambio (opcional) * @returns {Promise<Object>} - Resultado de la operación */export const updateOrderStatus = async (orderId, newStatus, adminId, notes = '') => {  try {    if (!orderId || !newStatus || !adminId) {      return { ok: false, error: 'Faltan datos requeridos' };    }    // Obtener el pedido actual    const result = await getOrderById(orderId);    if (!result.ok) {      return result;    }    const order = result.data;    const currentStatus = order.status;    // Verificar si el cambio de estado es válido según el flujo de trabajo    const isValidTransition = validateStatusTransition(currentStatus, newStatus);    if (!isValidTransition) {      return {         ok: false,         error: `Transición no válida: ${currentStatus} ? ${newStatus}`       };    }    // Crear registro histórico del cambio    const statusChange = {      from: currentStatus,      to: newStatus,      changedAt: new Date(),      changedBy: adminId,      notes    };    // Actualizar el pedido    const orderRef = doc(FirebaseDB, ORDERS_COLLECTION, orderId);    await updateDoc(orderRef, {      status: newStatus,      statusHistory: [...(order.statusHistory || []), statusChange],      updatedAt: serverTimestamp()    });    // Si el cambio es a "shipped", verificar si hay información de envío    if (newStatus === 'shipped' && (!order.shipping || !order.shipping.trackingInfo)) {      // Registrar una advertencia interna      console.warn(`Orden ${orderId} marcada como enviada sin información de seguimiento`);    }    // Si el cambio es a estado "completed" o "cancelled", notificar al cliente    if (newStatus === 'completed' || newStatus === 'cancelled') {      try {        await sendOrderStatusNotification(order.userId, orderId, newStatus, notes);      } catch (notificationError) {        console.error('Error al enviar notificación:', notificationError);        // No interrumpir el flujo si hay error en la notificación      }    }    return { ok: true, error: null };  } catch (error) {    console.error('Error al actualizar estado del pedido:', error);    return { ok: false, error: error.message };  }};/** * Valida si la transición de estado es permitida según el flujo de trabajo * @param {string} currentStatus - Estado actual * @param {string} newStatus - Nuevo estado * @returns {boolean} - true si la transición es válida */const validateStatusTransition = (currentStatus, newStatus) => {  // Definir transiciones permitidas  const allowedTransitions = {    'pending': ['processing', 'cancelled'],    'processing': ['shipped', 'cancelled'],    'shipped': ['delivered', 'cancelled'],    'delivered': ['completed', 'returned'],    'completed': ['returned'],    'returned': [],    'cancelled': ['pending'] // Solo admins pueden reactivar  };  // Verificar si la transición está permitida  return allowedTransitions[currentStatus]?.includes(newStatus) || false;};Diagrama de flujoCálculo de la Complejidad CiclomáticaNoDescripción1¿Parámetros completos? (Nodo 1)2¿Pedido encontrado? (Nodo 4)3¿Transición válida? (Nodo 8)4¿Nuevo estado es “shipped”? (Nodo 12)5¿Tiene información de envío? (Nodo 13)6¿Estado es “completed” o “cancelled”? (Nodo 15)7¿Error en notificación? (Nodo 17)8¿Bloque try-catch? (entre nodo 1 y nodo 20)ElementoValorNúmero de Regiones9Nodos21Aristas28Fórmula Aristas - Nodos + 228 - 21 + 2 = 9Nodos Predicado (decisiones)8Cálculo Nodos predicado + 18 + 1 = 9ConclusiónLa complejidad ciclomática es 9, lo que implica que se deben identificar 9 caminos independientes dentro del grafo.Determinación del Conjunto Básico de Caminos IndependientesNoDescripciónSecuencia de nodos1Error: parámetros incompletos1(No) ? 2 ? Fin2Error: pedido no encontrado1(Sí) ? 3 ? 4(No) ? 5 ? Fin3Error: transición no válida1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(No) ? 9 ? Fin4Excepción inesperada1(Sí) ? 3 ? (excepción) ? 20 ? 21 ? Fin5Actualización simple sin notificaciones1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(Sí) ? 10 ? 11 ? 12(No) ? 15(No) ? 19 ? Fin6Actualización a “shipped” sin tracking1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(Sí) ? 10 ? 11 ? 12(Sí) ? 13(No) ? 14 ? 15(No) ? 19 ? Fin7Actualización a “shipped” con tracking1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(Sí) ? 10 ? 11 ? 12(Sí) ? 13(Sí) ? 15(No) ? 19 ? Fin8Actualización a “completed” con notificación exitosa1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(Sí) ? 10 ? 11 ? 12(No) ? 15(Sí) ? 16 ? 17(No) ? 19 ? Fin9Actualización a “cancelled” con error en notificación1(Sí) ? 3 ? 4(Sí) ? 6 ? 7 ? 8(Sí) ? 10 ? 11 ? 12(No) ? 15(Sí) ? 16 ? 17(Sí) ? 18 ? 19 ? FinDerivación de Casos de PruebaNoCaso de PruebaDatos de EntradaResultado Esperado1Parámetros incompletosorderId = null, newStatus = “shipped”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”Retorna { ok: false, error: ‘Faltan datos requeridos’ }2Pedido no encontradoorderId = “orderInexistente”, newStatus = “shipped”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”Retorna { ok: false, error: “Pedido no encontrado” }3Transición no válidaorderId = “0CtVdxOrrU6DuWAWqaoD”, newStatus = “completed”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “pending”Retorna { ok: false, error: “Transición no válida: pending ? completed” }4Excepción inesperadaorderId = “FPmnBbHmH5TwkrARmfTB”, newStatus = “shipped”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, updateDoc lanza excepciónRetorna { ok: false, error: “Mensaje del error lanzado” }5Actualización a “processing”orderId = “0CtVdxOrrU6DuWAWqaoD”, newStatus = “processing”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “pending”Actualiza el documento, actualiza historial y retorna { ok: true, error: null }6Actualización a “shipped” sin trackingorderId = “17rt2Q26erpFj75ZcxKM”, newStatus = “shipped”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “processing”, sin trackingRegistra advertencia, actualiza documento y retorna { ok: true, error: null }7Actualización a “shipped” con trackingorderId = “17rt2Q26erpFj75ZcxKM”, newStatus = “shipped”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “processing”, con trackingActualiza documento y retorna { ok: true, error: null }8Actualización a “completed” con notificaciónorderId = “2DY2sr0ZNNMhQL4yZat2”, newStatus = “completed”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “delivered”Envía notificación, actualiza documento y retorna { ok: true, error: null }9Cancelación con error en notificaciónorderId = “FPmnBbHmH5TwkrARmfTB”, newStatus = “cancelled”, adminId = “MNQKuTrk7cTNUm9NDQRalyHrRL92”, estado actual = “pending”, email arroja errorSe registra error, se actualiza documento y retorna { ok: true, error: null }