/**
 * ShippingDebugger.js
 * 
 * Utilidad para depurar problemas con las opciones de env√≠o
 * Muestra informaci√≥n detallada sobre direcciones, productos y reglas
 */

// Importar la funci√≥n findBestShippingOptions desde el algoritmo Greedy
import { findBestShippingOptions } from '../../../shop/features/checkout/services/shipping/ShippingRulesGreedy';

// Reimplementaci√≥n de isRuleValidForAddress para diagn√≥stico
const greedyIsRuleValidForAddress = (rule, address) => {
  if (!rule || !address) return { valid: false, reason: 'Falta regla o direcci√≥n' };
  
  // Normalizar datos para comparaci√≥n
  const postalCode = (address.postalCode || address.zip || '').toString().trim();
  const state = (address.state || address.provincia || '').toString().toLowerCase().trim();
  const country = (address.country || 'MX').toString().toLowerCase().trim();
  
  // A√±adir logs detallados para diagn√≥stico
  console.log(`üîç DEBUG greedyIsRuleValidForAddress: Rule ID=${rule.id}, Coverage Type=${rule.coverage_type || rule.tipo_cobertura || 'undefined'}`);
  
  // Verificar tipo de cobertura
  switch(rule.coverage_type || rule.tipo_cobertura) {
    // Cobertura nacional
    case 'nacional':
      console.log(`‚úÖ Regla ${rule.id} - Cobertura nacional, es v√°lida autom√°ticamente`);
      return { valid: true, reason: 'Cobertura nacional' };
    
    // Cobertura por c√≥digo postal
    case 'por_codigo_postal':
    case 'postal_code':
      if (!Array.isArray(rule.coverage_values)) {
        console.log(`‚ùå Regla ${rule.id} - coverage_values no es un array`);
        return { valid: false, reason: 'coverage_values no es un array' };
      }
      
      const matchingCP = rule.coverage_values.find(cp => cp.toString().trim() === postalCode);
      if (matchingCP) {
        console.log(`‚úÖ Regla ${rule.id} - CP coincidente: ${matchingCP}`);
        return { valid: true, reason: `C√≥digo postal coincidente: ${matchingCP}` };
      }
      console.log(`‚ùå Regla ${rule.id} - CP ${postalCode} no est√° en coverage_values: [${rule.coverage_values.join(', ')}]`);
      return { valid: false, reason: `C√≥digo postal ${postalCode} no est√° en coverage_values` };
    
    // Cobertura por estado/provincia
    case 'por_estado':
    case 'state':
      if (!Array.isArray(rule.coverage_values)) {
        console.log(`‚ùå Regla ${rule.id} - coverage_values no es un array para estado`);
        return { valid: false, reason: 'coverage_values no es un array' };
      }
      
      const matchingState = rule.coverage_values.find(s => s.toString().toLowerCase().trim() === state);
      if (matchingState) {
        console.log(`‚úÖ Regla ${rule.id} - Estado coincidente: ${matchingState}`);
        return { valid: true, reason: `Estado coincidente: ${matchingState}` };
      }
      console.log(`‚ùå Regla ${rule.id} - Estado ${state} no est√° en coverage_values: [${rule.coverage_values.join(', ')}]`);
      return { valid: false, reason: `Estado ${state} no est√° en coverage_values` };
             
    // Cobertura por pa√≠s
    case 'por_pais':
    case 'country':
      if (rule.coverage_country?.toLowerCase().trim() === country) {
        console.log(`‚úÖ Regla ${rule.id} - Pa√≠s coincidente: ${rule.coverage_country}`);
        return { valid: true, reason: `Pa√≠s coincidente: ${rule.coverage_country}` };
      }
      console.log(`‚ùå Regla ${rule.id} - Pa√≠s ${country} no coincide con ${rule.coverage_country}`);
      return { valid: false, reason: `Pa√≠s ${country} no coincide con ${rule.coverage_country}` };
      
    default:
      // Sin tipo de cobertura definido
      if (!rule.coverage_type && !rule.tipo_cobertura) {
        console.log(`‚ùå Regla ${rule.id} - Sin tipo de cobertura definido`);
        return { valid: false, reason: 'Regla sin tipo de cobertura definido (coverage_type o tipo_cobertura)' };
      }
      console.log(`‚ùå Regla ${rule.id} - Tipo de cobertura desconocido: ${rule.coverage_type || rule.tipo_cobertura}`);
      return { valid: false, reason: `Tipo de cobertura desconocido: ${rule.coverage_type || rule.tipo_cobertura}` };
  }
  
  // Verificar campos alternativos (compatibilidad con esquema actual)
  if (Array.isArray(rule.cobertura_cp)) {
    const matchingCP = rule.cobertura_cp.find(cp => cp.toString().trim() === postalCode);
    if (matchingCP) {
      console.log(`‚úÖ Regla ${rule.id} - CP coincidente en cobertura_cp: ${matchingCP}`);
      return { valid: true, reason: `C√≥digo postal coincidente en cobertura_cp: ${matchingCP}` };
    }
  }
  
  if (Array.isArray(rule.cobertura_estados)) {
    const matchingState = rule.cobertura_estados.find(s => s.toString().toLowerCase().trim() === state);
    if (matchingState) {
      console.log(`‚úÖ Regla ${rule.id} - Estado coincidente en cobertura_estados: ${matchingState}`);
      return { valid: true, reason: `Estado coincidente en cobertura_estados: ${matchingState}` };
    }
  }
  
  console.log(`‚ùå Regla ${rule.id} - No se encontraron coincidencias en ning√∫n campo`);
  return { valid: false, reason: 'No se encontraron coincidencias en ning√∫n campo' };
};

// Funci√≥n para convertir reglas al formato esperado por Greedy
const convertRuleToGreedyFormat = (rule, address) => {
  if (!rule) return null;
  
  const newRule = { ...rule };
  const postalCode = (address.postalCode || address.zip || '').toString().trim();
  const state = (address.state || address.provincia || '').toString().toLowerCase().trim();
  
  // Verificar si necesitamos asignar tipo de cobertura
  if (!newRule.coverage_type && !newRule.tipo_cobertura) {
    // Si tiene c√≥digo postal espec√≠fico
    if (rule.zipcode) {
      // Caso especial para prefijo estado_
      if (rule.zipcode.startsWith('estado_')) {
        newRule.coverage_type = 'por_estado';
        newRule.coverage_values = [state];
        newRule.cobertura_estados = [state];
      } else {
        newRule.coverage_type = 'por_codigo_postal';
        newRule.coverage_values = [rule.zipcode];
        newRule.cobertura_cp = [rule.zipcode];
      }
    }
    // Si tiene array de c√≥digos postales
    else if (rule.zipcodes && Array.isArray(rule.zipcodes)) {
      newRule.coverage_type = 'por_codigo_postal';
      newRule.coverage_values = [...rule.zipcodes];
      newRule.cobertura_cp = [...rule.zipcodes];
    }
    // Si tiene zona
    else if (rule.zona) {
      // Para zona nacional o Local
      if (rule.zona === 'Nacional' || rule.zona === 'Local') {
        newRule.coverage_type = 'nacional';
      } else {
        // Asumir que zona es un estado
        newRule.coverage_type = 'por_estado';
        newRule.coverage_values = [rule.zona.toLowerCase()];
        newRule.cobertura_estados = [rule.zona.toLowerCase()];
      }
    }
  }
  
  return newRule;
};

/**
 * Funci√≥n que imprime informaci√≥n detallada sobre el estado actual del checkout
 * @param {Object} address - Direcci√≥n seleccionada
 * @param {Array} cartItems - Productos en el carrito
 * @param {Array} shippingRules - Reglas de env√≠o (opcional)
 */
export const debugShipping = (address, cartItems, shippingRules = null) => {
  console.group('üîç DEPURACI√ìN DE ENV√çO');
  
  // Informaci√≥n sobre la direcci√≥n
  console.group('üìç DIRECCI√ìN SELECCIONADA');
  if (!address) {
    console.warn('‚ö†Ô∏è No hay direcci√≥n seleccionada');
  } else {
    console.log('ID:', address.id);
    console.log('Ciudad:', address.city);
    console.log('Estado/Provincia:', address.state || address.provincia);
    console.log('C√≥digo Postal:', address.postalCode || address.zip || address.zipcode);
    console.log('Pa√≠s:', address.country || 'M√©xico');
    console.log('Direcci√≥n completa:', address);
  }
  console.groupEnd();
  
  // Informaci√≥n sobre los productos
  console.group('üõí PRODUCTOS EN CARRITO');
  if (!cartItems || !Array.isArray(cartItems) || cartItems.length === 0) {
    console.warn('‚ö†Ô∏è No hay productos en el carrito');
  } else {
    console.log(`Total de productos: ${cartItems.length}`);
    cartItems.forEach((item, index) => {
      const product = item.product || item;
      console.group(`Producto #${index + 1}: ${product.name || product.title || 'Sin nombre'}`);
      console.log('ID:', product.id);
      console.log('Peso:', product.weight || product.peso || 'No especificado');
      console.log('Cantidad:', item.quantity || 1);
      
      // Mostrar las reglas asignadas al producto
      if (product.shippingRuleId) {
        console.log('Regla de env√≠o asignada:', product.shippingRuleId);
      }
      if (product.shippingRuleIds && Array.isArray(product.shippingRuleIds)) {
        console.log('Reglas de env√≠o asignadas:', product.shippingRuleIds);
      }
      
      console.log('Producto completo:', product);
      console.groupEnd();
    });
  }
  console.groupEnd();
  
  // Informaci√≥n sobre las reglas de env√≠o (si est√°n disponibles)
  console.group('üìè REGLAS DE ENV√çO');
  if (!shippingRules) {
    console.log('‚ö†Ô∏è Reglas no proporcionadas en la depuraci√≥n');
  } else if (!Array.isArray(shippingRules) || shippingRules.length === 0) {
    console.warn('‚ö†Ô∏è No hay reglas de env√≠o disponibles');
  } else {
    console.log(`Total de reglas: ${shippingRules.length}`);
    shippingRules.forEach((rule, index) => {
      console.group(`Regla #${index + 1}: ${rule.nombre || rule.name || 'Sin nombre'}`);
      console.log(`ID: ${rule.id}`);
      console.log(`Activa: ${rule.activo || rule.active ? 'S√≠' : 'No'}`);
      console.log(`Zonas: ${rule.zones?.length || 0}`);
      
      // Mostrar el campo zona claramente
      console.log(`Nombre de zona: ${rule.zona || 'No definido'}`);
      
      // A√±adir informaci√≥n sobre tiempos de entrega
      console.log(`Tiempo m√≠nimo: ${rule.tiempo_minimo || rule.min_days || 'No definido'}`);
      console.log(`Tiempo m√°ximo: ${rule.tiempo_maximo || rule.max_days || 'No definido'}`);
      
      if (rule.zipcode) {
        console.log(`C√≥digo postal espec√≠fico: ${rule.zipcode}`);
      }
      
      if (rule.zipcodes && Array.isArray(rule.zipcodes)) {
        console.log('C√≥digos postales:', rule.zipcodes);
      }
      
      if (rule.zones?.length) {
        console.log('Primera zona:', rule.zones[0]);
      }
      console.log('Regla completa:', rule);
      console.groupEnd();
    });
  }
  console.groupEnd();
  
  // Verificaci√≥n de compatibilidad de env√≠o
  console.group('üß™ VERIFICACI√ìN DE COMPATIBILIDAD');
  
  if (!address) {
    console.warn('‚ö†Ô∏è No se puede verificar sin direcci√≥n');
  } else if (!cartItems || !Array.isArray(cartItems) || cartItems.length === 0) {
    console.warn('‚ö†Ô∏è No se puede verificar sin productos');
  } else if (!shippingRules || !Array.isArray(shippingRules) || shippingRules.length === 0) {
    console.warn('‚ö†Ô∏è No se puede verificar sin reglas de env√≠o');
  } else {
    // Verificar c√≥digo postal
    const postalCode = address.postalCode || address.zip || address.zipcode || '';
    if (!postalCode) {
      console.warn('‚ö†Ô∏è La direcci√≥n no tiene c√≥digo postal');
    } else {
      console.log('‚úÖ C√≥digo postal presente:', postalCode);
      
      // Verificar si alguna regla aplica para este c√≥digo postal
      let matchFound = false;
      
      shippingRules.forEach(rule => {
        // Primera verificaci√≥n: c√≥digo postal directo
        if (rule.zipcode === postalCode) {
          matchFound = true;
          console.log(`‚úÖ Regla ${rule.id} aplica por c√≥digo postal exacto:`, postalCode);
        }
        
        // Segunda verificaci√≥n: prefijo estado_
        if (rule.zipcode === `estado_${address.state?.substring(0, 3).toUpperCase()}`) {
          matchFound = true;
          console.log(`‚úÖ Regla ${rule.id} aplica por prefijo estado:`, rule.zipcode);
        }
        
        // Tercera verificaci√≥n: array de zipcodes
        if (rule.zipcodes && Array.isArray(rule.zipcodes) && rule.zipcodes.includes(postalCode)) {
          matchFound = true;
          console.log(`‚úÖ Regla ${rule.id} aplica por array de c√≥digos postales`);
        }
        
        // Cuarta verificaci√≥n: zona = estado
        if (rule.zona && rule.zona.toLowerCase() === address.state?.toLowerCase()) {
          matchFound = true;
          console.log(`‚úÖ Regla ${rule.id} aplica por zona (${rule.zona}) = estado (${address.state})`);
        }
        
        // Quinta verificaci√≥n: zona "Local"
        if (rule.zona === 'Local') {
          matchFound = true;
          console.log(`‚úÖ Regla ${rule.id} aplica por zona Local`);
        }
        
        const matchingZone = rule.zones?.find(zone => {
          // Verificar si el c√≥digo postal est√° en el rango
          if (zone.zipCodes) {
            return zone.zipCodes.some(zipRange => {
              if (typeof zipRange === 'string' && zipRange.includes('-')) {
                const [start, end] = zipRange.split('-').map(z => parseInt(z.trim(), 10));
                const zip = parseInt(postalCode, 10);
                return zip >= start && zip <= end;
              }
              return zipRange === postalCode;
            });
          }
          
          // Verificar por estado/provincia
          if (zone.states && address.state) {
            return zone.states.some(state => 
              state.toLowerCase() === address.state.toLowerCase());
          }
          
          return false;
        });
        
        if (matchingZone) {
          matchFound = true;
          console.log('‚úÖ Zona de env√≠o encontrada:', matchingZone);
        }
      });
      
      if (!matchFound) {
        console.warn('‚ö†Ô∏è No se encontr√≥ ninguna zona de env√≠o para este c√≥digo postal/estado');
      }
    }
    
    // Verificar peso de productos
    const hasWeightInfo = cartItems.every(item => {
      const product = item.product || item;
      return product.weight || product.peso;
    });
    
    if (!hasWeightInfo) {
      console.warn('‚ö†Ô∏è Algunos productos no tienen informaci√≥n de peso');
    } else {
      console.log('‚úÖ Todos los productos tienen informaci√≥n de peso');
    }
  }
  console.groupEnd();
  
  // DIAGN√ìSTICO AVANZADO: Verificaci√≥n profunda del algoritmo Greedy
  console.group('üî¨ DIAGN√ìSTICO AVANZADO (ALGORITMO GREEDY)');
  
  if (!address || !cartItems || !shippingRules) {
    console.warn('‚ö†Ô∏è No se puede realizar diagn√≥stico avanzado sin direcci√≥n, productos y reglas');
  } else {
    // Comprobar validaci√≥n de reglas seg√∫n el algoritmo Greedy
    console.group('1. Validaci√≥n de reglas seg√∫n formato Greedy:');
    
    const validRules = [];
    const invalidRules = [];
    
    shippingRules.forEach(rule => {
      const result = greedyIsRuleValidForAddress(rule, address);
      
      if (result.valid) {
        validRules.push(rule);
        console.log(`‚úÖ Regla ${rule.id || 'sin ID'} (${rule.name || 'sin nombre'}): V√ÅLIDA - ${result.reason}`);
      } else {
        invalidRules.push({ rule, reason: result.reason });
        console.log(`‚ùå Regla ${rule.id || 'sin ID'} (${rule.name || 'sin nombre'}): INV√ÅLIDA - ${result.reason}`);
      }
    });
    
    console.log(`Resumen: ${validRules.length} reglas v√°lidas, ${invalidRules.length} reglas inv√°lidas`);
    
    if (invalidRules.length > 0) {
      console.group('Problemas encontrados en reglas:');
      
      const commonProblems = {
        noCoverageType: 0,
        noValues: 0,
        wrongFormat: 0
      };
      
      invalidRules.forEach(({ rule, reason }) => {
        if (reason.includes('tipo de cobertura')) {
          commonProblems.noCoverageType++;
        } else if (reason.includes('no es un array') || reason.includes('coverage_values')) {
          commonProblems.noValues++;
        } else if (reason.includes('No se encontraron coincidencias')) {
          commonProblems.wrongFormat++;
        }
      });
      
      console.log('Problemas frecuentes:');
      console.log(`- Reglas sin tipo de cobertura: ${commonProblems.noCoverageType}`);
      console.log(`- Reglas sin valores de cobertura: ${commonProblems.noValues}`);
      console.log(`- Reglas con formato incorrecto: ${commonProblems.wrongFormat}`);
      
      console.groupEnd();
    }
    
    console.groupEnd();
    
    // Verificar si alguna regla v√°lida est√° asignada a productos
    console.group('2. Verificaci√≥n de asignaci√≥n de reglas a productos:');
    
    if (validRules.length === 0) {
      console.error('‚ùå No hay reglas v√°lidas para esta direcci√≥n - NO se podr√° calcular env√≠o');
    } else {
      // Obtener los IDs de las reglas v√°lidas
      const validRuleIds = validRules.map(rule => rule.id);
      
      // Verificar si cada producto tiene al menos una regla v√°lida
      const productsWithValidRules = [];
      const productsWithoutValidRules = [];
      
      cartItems.forEach(item => {
        const product = item.product || item;
        const productRuleIds = [];
        
        if (product.shippingRuleId) {
          productRuleIds.push(product.shippingRuleId);
        }
        
        if (product.shippingRuleIds && Array.isArray(product.shippingRuleIds)) {
          productRuleIds.push(...product.shippingRuleIds);
        }
        
        // Verificar si alguna de las reglas del producto es v√°lida
        const hasValidRule = productRuleIds.some(ruleId => validRuleIds.includes(ruleId));
        
        if (hasValidRule) {
          productsWithValidRules.push(product);
        } else {
          productsWithoutValidRules.push(product);
        }
      });
      
      console.log(`‚úÖ Productos con reglas v√°lidas: ${productsWithValidRules.length}`);
      console.log(`‚ùå Productos sin reglas v√°lidas: ${productsWithoutValidRules.length}`);
      
      if (productsWithoutValidRules.length > 0) {
        console.error('‚ùå Hay productos sin reglas v√°lidas - NO se podr√° calcular env√≠o para todo el carrito');
        console.group('Productos sin reglas v√°lidas:');
        
        productsWithoutValidRules.forEach(product => {
          console.log(`- ${product.name || product.title || product.id}`);
          console.log('  Reglas asignadas:', product.shippingRuleIds || product.shippingRuleId || 'ninguna');
        });
        
        console.groupEnd();
      }
    }
    
    console.groupEnd();
    
    // Soluci√≥n propuesta: Convertir reglas al formato esperado por Greedy
    console.group('3. Soluci√≥n propuesta: Convertir reglas al formato Greedy');
    
    // Ejemplos de reglas problem√°ticas y su soluci√≥n
    const problemRules = invalidRules.slice(0, 3); // Tomar hasta 3 reglas problem√°ticas como ejemplo
    
    if (problemRules.length > 0) {
      problemRules.forEach(({ rule }) => {
        console.group(`Regla problem√°tica: ${rule.id || 'sin ID'}`);
        
        console.log('Formato original:');
        console.log(JSON.stringify({
          id: rule.id,
          coverage_type: rule.coverage_type,
          tipo_cobertura: rule.tipo_cobertura,
          coverage_values: rule.coverage_values,
          zipcode: rule.zipcode,
          zona: rule.zona,
          zipcodes: rule.zipcodes
        }, null, 2));
        
        const fixedRule = convertRuleToGreedyFormat(rule, address);
        
        console.log('Formato corregido:');
        console.log(JSON.stringify({
          id: fixedRule.id,
          coverage_type: fixedRule.coverage_type,
          coverage_values: fixedRule.coverage_values,
          cobertura_cp: fixedRule.cobertura_cp,
          cobertura_estados: fixedRule.cobertura_estados
        }, null, 2));
        
        const validationResult = greedyIsRuleValidForAddress(fixedRule, address);
        console.log(`Resultado de validaci√≥n: ${validationResult.valid ? '‚úÖ V√ÅLIDA' : '‚ùå INV√ÅLIDA'} - ${validationResult.reason}`);
        
        console.groupEnd();
      });
      
      console.log('üìù Conclusi√≥n: Es necesario convertir las reglas al formato esperado por el algoritmo Greedy');
      console.log('Esto implica transformar campos como zipcode y zona a coverage_type y coverage_values');
    } else {
      console.log('No hay ejemplos de reglas problem√°ticas para mostrar');
    }
    
    console.groupEnd();
  }
  
  console.groupEnd();
  console.groupEnd();
};

/**
 * Funci√≥n para ser usada en componentes React
 * Se integra con useEffect para mostrar la informaci√≥n cuando cambia la direcci√≥n
 * @param {Object} params - Par√°metros del hook
 * @param {Object} params.address - Direcci√≥n seleccionada
 * @param {Array} params.cartItems - Productos en el carrito
 * @param {Array} params.shippingRules - Reglas de env√≠o (opcional)
 */
export const useShippingDebugger = ({ address, cartItems, shippingRules }) => {
  if (process.env.NODE_ENV !== 'production') {
    debugShipping(address, cartItems, shippingRules);
  }
};

export default debugShipping; 